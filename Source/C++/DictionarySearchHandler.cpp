#include "../Include/Server.hpp"
#include "../Include/DictionarySearchHandler.hpp"

#include <iostream>

#include "../Include/sqlite3.h"
#include "../Include/WebpageBuilder.hpp"


const std::string DictionarySearchHandler::SEARCH_QUERY =
        "SELECT WordID, EntryID, XML FROM Entry JOIN WordEntries ON WordEntries.EntryID = Entry.ID JOIN Word ON Word.ID = WordEntries.WordID WHERE Word.Name = LOWER(?) ORDER BY ItemOrder ASC;";


bool DictionarySearchHandler::handleGet(CivetServer *server,
                                        mg_connection *connection)
{
    const mg_request_info *requestInfo;
    const char *queryString;
    size_t uriSize;
    WebpageBuilder *webpageBuilder;



    webpageBuilder = new WebpageBuilder("Dictionary", "en");
    requestInfo = mg_get_request_info(connection);
    queryString = requestInfo->query_string;


    webpageBuilder->closeHead();
    webpageBuilder->append(R"(
            <form action="/Dictionary" method="get" autocomplete="off">
                <label for="dictionary-selection-combo-box">Language</label>
                <!-- TODO: This list should be generated by the server. -->
                <select id="dictionary-selection-combo-box" name="dictionary">
                    <option value="en-2024">English (2024)</option>
                    <option value="en-2019">English (2019)</option>

                    <option value="de">German</option>
                    <option value="de-en">German-English</option>
                    <option value="en-de">English-German</option>

                    <option value="es">Spanish</option>
                    <option value="es-en">Spanish-English</option>
                    <option value="en-es">English-Spanish</option>

                    <option value="fr">French</option>
                    <option value="fr-en">French-English</option>
                    <option value="en-fr">English-French</option>

                    <option value="it">Italian</option>
                    <option value="it-en">Italian-English</option>
                    <option value="en-it">English-Italian</option>

                    <option value="ja">Japanese</option>
                    <option value="en-ja">English-Japanese</option>

                    <option value="nl">Dutch</option>

                    <option value="pt">Portuguese</option>
                    <option value="pt-en">Portuguese-English</option>
                    <option value="en-pt">English-Portuguese</option>
                </select>

                <label for ="search-box">Search</label>
                <input id="search-box" type="search" name="word" required />

                <input type="submit" value="Search" />
                </form>
                <ul id="path-bar">
                    <li class="list-button">
                        <a href="/">Home</a>
                    </li>
                    <li class="list-button">
                        <b>Dictionary</b>
                    </li>
                </ul>)");
    webpageBuilder->closeNav();
    webpageBuilder->append("<main>");


    if (queryString == nullptr)
    {
        webpageBuilder->append("</main>");
        webpageBuilder->closeWrapper();
        webpageBuilder->closeBody();

        std::string responseBody;

        responseBody = webpageBuilder->toString();

        mg_printf(connection, OK_HEADER, webpageBuilder->getSize());
        mg_write(connection, responseBody.c_str(), webpageBuilder->getSize());

        return true;
    }



    uriSize = strlen(queryString);

    char *dictionaryName;
    int dictionaryNameSize;


    dictionaryName = static_cast<char *>(malloc(uriSize + STRLEN_OFFSET));
    dictionaryNameSize = mg_get_var(queryString,
                                    uriSize,
                                    "dictionary",
                                    dictionaryName,
                                    uriSize + STRLEN_OFFSET);

    if (dictionaryNameSize == MG_GET_VAR_DESTINATION_BUFFER_TOO_SMALL)
    {
        webpageBuilder->append("<p>Not enough memory was allocated for the dictionary name. <b>This is a bug</b>; please report it at <a href=\"");
        webpageBuilder->append(PRODUCT_REPOSITORY);
        webpageBuilder->append("\">");
        webpageBuilder->append(PRODUCT_REPOSITORY);
        webpageBuilder->append("</a>.</p>");

        return false;
    }

    if (dictionaryNameSize == MG_GET_VAR_VARIABLE_NOT_FOUND)
    {
        webpageBuilder->append("<p>A dictionary name was not specified.<p>");

        return false;
    }


    char *word;
    int wordSize;


    word = static_cast<char *>(malloc(uriSize + STRLEN_OFFSET));
    wordSize = mg_get_var(queryString, uriSize, "word", word, uriSize + STRLEN_OFFSET);

    if (wordSize == MG_GET_VAR_DESTINATION_BUFFER_TOO_SMALL)
    {
        webpageBuilder->append(PRODUCT_REPOSITORY);
        webpageBuilder->append("\">");
        webpageBuilder->append(PRODUCT_REPOSITORY);
        webpageBuilder->append("</a>.</p>");
        webpageBuilder->append("<p>Not enough memory was allocated for the word. <b>This is a bug</b>; please report it at <a href=\"");

        return false;
    }

    if (wordSize == MG_GET_VAR_VARIABLE_NOT_FOUND)
    {
        webpageBuilder->append("A word was not specified.");

        return false;
    }


    if (!validateDictionaryFileName(dictionaryName))
    {
        webpageBuilder->append("The dictionary, \"");
        webpageBuilder->append(dictionaryName);
        webpageBuilder->append("\" does not exist.");

        return false;
    }


    sqlite3 *sqliteHandle;
    std::string dictionaryFilePath(DICTIONARIES_PATH);
    int sqliteResult;


    dictionaryFilePath.append(dictionaryName);
    dictionaryFilePath.append(".db");

    sqliteResult = sqlite3_open(dictionaryFilePath.c_str(), &sqliteHandle);

    if (sqliteResult != SQLITE_OK)
    {
        webpageBuilder->append("The database, <code>");
        webpageBuilder->append(dictionaryFilePath.c_str());
        webpageBuilder->append("</code> could not be opened.");

        sqlite3_close(sqliteHandle);

        return false;
    }


    // Select Entries
    // TODO: Remove magic numbers
    sqlite3_stmt *queryPreparedStatement;

    sqliteResult = sqlite3_prepare_v2(sqliteHandle,
                                      SEARCH_QUERY.c_str(),
                                      SQLITE_READ_UP_TO_NULL_TERMINATOR,
                                      &queryPreparedStatement,
                                      SQLITE_PREPARED_STATEMENT_PARAMETER_NOT_IMPORTANT);

    if (sqliteResult != SQLITE_OK)
    {
        webpageBuilder->append("Could not retrieve results.");
        sqlite3_close(sqliteHandle);

        return false;
    }


    sqlite3_bind_text(queryPreparedStatement, WORD_INDEX, word, wordSize, SQLITE_STATIC);


    sqliteResult = sqlite3_step(queryPreparedStatement);

    if (sqliteResult != SQLITE_ROW)
    {
        webpageBuilder->append("No results.");
    }

    while (sqliteResult == SQLITE_ROW)
    {
        const unsigned char *xml;

        xml = sqlite3_column_text(queryPreparedStatement, XML_ROW_INDEX);

        webpageBuilder->append((char *) xml);

        sqliteResult = sqlite3_step(queryPreparedStatement);
    }


    webpageBuilder->append("</main>");
    webpageBuilder->closeWrapper();
    webpageBuilder->closeBody();


    std::string responseBody;

    responseBody = webpageBuilder->toString();

    mg_printf(connection, OK_HEADER, webpageBuilder->getSize());
    mg_write(connection, responseBody.c_str(), webpageBuilder->getSize());
    sqlite3_finalize(queryPreparedStatement);
    sqlite3_close(sqliteHandle);

    return true;
}


bool DictionarySearchHandler::validateDictionaryFileName(char *fileName)
{
    if (strcoll(fileName, "en-2024") == STRINGS_EQUAL)
    {
        return true;
    }
    else
    {
        return false;
    }
}
